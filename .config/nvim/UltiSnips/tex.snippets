global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C',
'CS', 'D', 'DS', 'E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS',
'J', 'JS', 'K', 'KS', 'L', 'LS', 'DS', 'V', 'W', 'X', 'Y', 'Z']]

texIgnoreMathZones = ['texMathText'] 
texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

ignore = texIgnoreMathZoneIds[0]

def math():
	synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
	try:
		first = next(
            i for i in reversed(synstackids)
            if i in texIgnoreMathZoneIds or i in texMathZoneIds
        )
		return first != ignore
	except StopIteration:
		return False
endglobal

context "math()"
snippet "([\S]+_|\^)([\-\w]{2,}|[,\w]{3,})" "Auto Sub/Super" wrA
`!p snip.rv = match.group(1)`{`!p snip.rv = match.group(2)`$1}$2
endsnippet

snippet frac "Fraction" w
\frac{${1:n}}{${2:d}}$3
endsnippet

snippet beg "Begin" b
\begin{$1}
    $2
\end{$1}
endsnippet

snippet def "Definition" b
\begin{definition}
    $1
\end{definition}
endsnippet

snippet thm "Theorem" b
\begin{thm}[${1:Title}]
    $2
\end{thm}
endsnippet

snippet pf "Proof" b
\begin{proof}
    $1
\end{proof}
endsnippet

snippet item "Itemize" b
\begin{itemize}[${1:<+->}]
    \item $0
\end{itemize}
endsnippet

snippet enum "Enumerate" b
\begin{enumerate}[${1:i.}]
    \item $0
\end{enumerate}
endsnippet

snippet em "Emph" w
\emph{$1}$2
endsnippet

snippet abs "Absolute" w
\abs{$1}$2
endsnippet

snippet bar "Bar" w
\bar{$1}$2
endsnippet

snippet hat "Hat" w
\hat{$1}$2
endsnippet

context "math()"
snippet "\|([^\w]*\w[\s\S]*?)\|" "Absolute" rA
\abs{`!p snip.rv = match.group(1)`}
endsnippet

context "math()"
snippet "\<(\S*)\|" "Bra" riA
\bra{`!p snip.rv = match.group(1)`}
endsnippet

context "math()"
snippet "\|(\S*)\>" "Ket" riA
\ket{`!p snip.rv = match.group(1)`}
endsnippet

context "math()"
snippet "(.*)\\bra{(.*?)}([^\|]*?)\>" "Braket" riA
`!p snip.rv = match.group(1)`\braket{`!p snip.rv = match.group(2)`}{`!p snip.rv = match.group(3)`}
endsnippet

snippet algo "Algorithm block" b
\begin{algorithm}
\begin{algorithmic}[1]
${3:\Function}
\end{algorithmic}
\caption{${1:caption}}
\label{alg:${2:label}}
\end{algorithm}
endsnippet

priority 10
snippet "mint(\S+)?" "Minted code typeset" br
\begin{minted}[]{${1:`!p
snip.rv = match.group(1) if match.group(1) is not None else "lang"`}}
${2:remember to fragile}
\end{minted}
endsnippet

priority 100
snippet "mintin" "Minted code inline" b
\mintinline{${1:lang}}|$2|$3
endsnippet

priority 1000
snippet math "Maxima block" w
math $1 math$0
endsnippet

priority 10000
snippet "math(.*)math" "Evaluate Maxima" wr
`!p import subprocess
cmd = match.group(1) + " tex(%, false);";
snip.rv = subprocess.check_output(['maxima', '--very-quiet', '--batch-string',
cmd], universal_newlines=True).split('\n')[-2]
`
endsnippet

snippet subfigure "Fig with subfigs" w
\begin{figure}[H] 
    \begin{subfigure}[${1:t}]{${2:0.45}\textwidth}
    \centering
    \includegraphics[width=\linewidth]{${3:}}
    \caption{${4:}}
    \label{fig:${5:}}
    \end{subfigure}
    \hspace{1em}
    \caption{${6:}}
    \label{fig:${7:}}
\end{figure}
endsnippet

snippet subfig "Subfigure" w
\begin{subfigure}[${1:t}]{${2:0.45}\textwidth}
    \centering
    \includegraphics[width=\linewidth]{${3:}}
    \caption{${4:}}
    \label{fig:${5:}}
\end{subfigure}
endsnippet

priority 1000
snippet ink "Inkscape preparation" w
fig $1 fig$0
endsnippet

priority 10000
snippet "fig (.*) fig" "Insert figure" wr
\begin{figure}[ht]
\centering
\def\svgwidth{${3:\linewidth}}
\import{./figures/}{${1:`!p
if snip.c != "":
    pass
else:
    import os
    import re

    figureDir = os.path.join(os.getcwd(), "figures/")
    # regex to make into kebab case
    figureName = "-".join([x.lower() for x in re.findall(r'\w+', match.group(1))])
    figurePath = figureDir + figureName + '.svg'

    if os.path.isfile(figurePath):
        snip.rv = "File already exists!"
    else:
        import subprocess
        templatePath = os.path.expanduser("~/.config/inkscape/templates/default1024.svg")
        subprocess.call(['mkdir', '-p', figureDir])
        subprocess.check_output(['cp', templatePath, figurePath])
        subprocess.call(['inkscape', '--export-type', 'pdf', '--export-latex', figurePath])
        snip.rv = figureName
`}.pdf_tex}
\caption{${2:caption}}
\label{fig:$1}
%edit $1 edit%$4
\end{figure}
$0
endsnippet

snippet "%edit (.*) edit%" "Edit svg" wr
%edit `!p
if snip.c != "":
    pass
else:
    import subprocess
    figureStem = os.path.join(os.getcwd(), "figures/", match.group(1))
    figurePath = figureStem + '.svg'
    proc = subprocess.Popen(['inkscape', figurePath]) # open in bg

    from inotify_simple import INotify, flags
    inotify = INotify()
    inotify.add_watch(figurePath, flags.MODIFY)

    update = lambda : subprocess.call(['inkscape', '--export-type', 'pdf', '--export-latex', figurePath])
    while True:
        if proc.poll() is not None:
            update()
            break # inkscape closed
        else:
            l = inotify.read(timeout=1000) # block and wait for inotify
            if (len(l) > 0):
                update()

    inotify.close()
    snip.rv = match.group(1)
` edit%$0
endsnippet
